---
title: 迷宫算法 - Eller’s  algorithm for maze generation
date: 2014-10-31 11:16:44
tags: [算法,游戏,迷宫]
---



Last time I talked about the recursive backtracker algorithm for maze generation. That’s probably always going to be my favorite algorithm for generating mazes, for a variety of reasons, but that’s not going to stop me from looking at others

`上次我谈到了 recursive backtracker 迷宫产生算法，这也许是我最喜欢的迷宫生成算法，出于多种原因，这不会阻止我去了解其他的算法。`

For one thing, there are some pretty crazy algorithms out there for generating mazes.

`首先，有许多疯狂的算法来生成迷宫。`

Eller’s algorithm is one of the craziest. It’s also one of the fastest. And it’s the only one I know that let’s you generate mazes of an infinite size. In linear time.

`Eller 的算法是其中一个，也是最快的算法之一。并且他是我所知道唯一一个可以生成无限大小的迷宫算法。在线性时间内。`

Yeah, it’s that crazy.

`是的，就是那么不可思议。`

It does this by building the maze one row at a time, using sets to keep track of which columns are ultimately connected. But it never needs to look at more than a single row, and when it finishes, it always produces a perfect maze.

`它每次构建迷宫的一行，使用集合去跟踪那些列是需要联通的。它不需要关注超过一行，当它完成时，它总是生成一个完美的迷宫。`

Like I did for the recursive backtracking algorithm, here’s the “mile-high” overview of Eller’s algorithm:

`像我处理 recursive backtracker 算法一样，在这里我概述一下Eller的算法。`

1. Initialize the cells of the first row to each exist in their own set.
2. Now, randomly join adjacent cells, but only if they are not in the same set. When joining adjacent cells, merge the cells of both sets into a single set, indicating that all cells in both sets are now connected (there is a path that connects any two cells in the set).
3. For each set, randomly create vertical connections downward to the next row. Each remaining set must have at least one vertical connection. The cells in the next row thus connected must share the set of the cell above them.
4. Flesh out the next row by putting any remaining cells into their own sets.
5. Repeat until the last row is reached.
6. For the last row, join all adjacent cells that do not share a set, and omit the vertical connections, and you’re done!



1. 在第一行初始化所有单元格为它们自身所在的集合中。
2. 现在，随机加入相邻的单元格，并且它们彼此不在同一个集合中，加入完成后，将这两个单元格所在的集合合并为一个，这表明所有的单元格 在这两个集合中并且是连通的。（在这个集合中有一个路径连通任意两个单元格）
3. 遍历所有集合，每个集合中的单元随机连通下一行，每个集合至少有一个单元向下连接。这些单元格在下一行中也因此能够与上一行相连。所以与上一行共享一个集合。
4. 填充下一行，（根据上一行每个集合中随机单元格联通到下一行，当前操作中这些单元格是已经确定了需要与上一行联通的）把剩余的单元格插入到集合中
5. 重复2和3，一直到最后一行。
6. 最后一行时，合并所有的相邻的单元格，忽略垂直向下的连通，然后你就已经完成了！


## An example 示例

First, we initialize each cell in that row to be in its own set. I’ll just assign each cell a number, indicating the set it belongs to:

`首先，我们在一行中初始化所有单元格，他们在各自的集合中。我为每个单元格设置了一个数字，表明它属于哪个集合`

	 ___________________
	|   |   |   |   |   |
	| 1 | 2 | 3 | 4 | 5 |
	|___|___|___|___|___|


Next, we randomly join adjacent cells that belong to different sets. The cells so joined also are merged into the same set:

`然后，我们随机加入两个相邻的单元格并且它们属于不同的集合。这些单元格被合并为一个集合`

	   ___________________
	  |           |       |
	  | 1   1   1 | 4   4 |
	  |___________|_______|


Now we randomly determine the vertical connections, at least one per set. The cells in the next row that we connected to must be assigned to the set of the cell above them:

`现在，我们让每个集合中的单元格随机的向下连通，每个集合至少保证有一个单元格向下联通`

	 ___________________
	|           |       |
	| 1   1   1 | 4   4 |
	|    ___    |___    |
	|   |   |   |   |   |
	| 1 |   | 1 |   | 4 |
	|___|   |___|   |___|


Next, we flesh out the next row, assigning each remaining cell to its own set:

`然后我们填充下一行，并且把剩余的单元格（上一步未设置连通的单元格）各设置为一个集合`

	   ___________________
	  |           |       |
	  | 1   1   1 | 4   4 |
	  |    ___    |___    |
	  |   |   |   |   |   |
	  | 1 | 6 | 1 | 7 | 4 |
	  |___|___|___|___|___|


At this point, we can actually discard the first row, because the algorithm is done with it. We’ll keep it around for now, though, for the sake of illustration. I’ll just put a little space between the previous rows, and the current row:

`在这里，我们其实可以丢弃第一行的数据了，它的作用已经完成了。我们尽量把注意力放在当前行，我在当前行与前一行增加了一些空距`

	   ___________________
	  |           |       |
	  | 1   1   1 | 4   4 |
	  |    ___    |___    |
	       ___     ___     
	  |   |   |   |   |   |
	  | 1 | 6 | 1 | 7 | 4 |
	  |___|___|___|___|___|


Now, we just repeat the previous steps on our new row. We randomly connect adjacent sets that do not share a set. Something like this:

`现在，我们只需要重复前面的操作来继续生成新的行。我们随机连接的相邻集合，（？ that do not share a set ）如图`

	       ___     ___     
	  |       |       |   |
	  | 1   1 | 1   1 | 4 |
	  |_______|_______|___|



Now we add at least one vertical connection for each set:

`现在我们为每个组至少添加一个垂直的连接`

	       ___     ___     
	  |       |       |   |
	  | 1   1 | 1   1 | 4 |
	  |___    |_______|   |
	      |   |       |   |
	      | 1 |       | 4 |
	      |___|       |___|


And then we flesh out the next row (I’m reusing some extinct set numbers here, for the sake of single-digits)

`然后我们填充下一行（我重用了一些已经用过的数字，为了保持集合的数字标识是个位数）`

		   ___     ___     
	  |       |       |   |
	  | 1   1 | 1   1 | 4 |
	  |___    |_______|   |
	  |   |   |   |   |   |
	  | 8 | 1 | 9 | 2 | 4 |
	  |___|___|___|___|___|


This is our current state, with history, now:

`这是我们现在的状态，历史和当前行`

	   ___________________
	  |           |       |
	  | 1   1   1 | 4   4 |
	  |    ___    |___    |
	  |       |       |   |
	  | 1   1 | 1   1 | 4 |
	  |___    |_______|   |
	   ___     ___ ___
	  |   |   |   |   |   |
	  | 8 | 1 | 9 | 2 | 4 |
	  |___|___|___|___|___|


It’s starting to look like a maze! Let’s do one more iteration, and then finish it out. So, first, randomly join adjacent cells from different sets:

`它开始看起来像一个迷宫了！让我们做一个迭代完成它。所以，首先随机加入不在一个集合内的两个单元格。`

	   ___     ___ ___
	  |   |   |           |
	  | 8 | 1 | 9   9   9 |
	  |___|___|___ ___ ___|



Then, add at least one veritcal connection for each set:

`然后为每个集合添加到下一行的的连通单元格，每个集合至少一个。`

	   ___     ___ ___
	  |   |   |           |
	  | 8 | 1 | 9   9   9 |
	  |   |   |___     ___|
	  |   |   |   |   |
	  | 8 | 1 |   | 9 |
	  |___|___|   |___|



And flesh out the next

`然后填充下一行。`

	   ___________________
	  |           |       |
	  | 1   1   1 | 9   9 |
	  |    ___    |___    |
	  |       |       |   |
	  | 1   1 | 1   1 | 9 |
	  |___    |_______|   |
	  |   |   |           |
	  | 8 | 1 | 9   9   9 |
	  |   |   |___     ___|
	           ___     ___
	  |   |   |   |   |   |
	  | 8 | 1 | 3 | 9 | 5 |
	  |___|___|___|___|___|


And now the last row. This time, we must connect ALL adjacent (but disjoint) cells. In this case, that means all of them:

`然后在最后一行时。我们必须连接所有的相邻的单元格，在这个例子中，就像图中一样`

	           ___     ___
	  |                   |
	  | 8   8   8   8   8 |
	  |___________________|

Since this is the last row, we skip the bit where we add verticals…and that means we’re done! The result, with set numbers removed, is:

`因为这是最后一行，我们跳过添加垂直连接这个步骤，这意味着我们已经完成了，把数字移除，我们看到的结果就是`

  	   ___________________
  	  |           |       |
  	  |           |       |
  	  |    ___    |___    |
  	  |       |       |   |
  	  |       |       |   |
  	  |___    |_______|   |
  	  |   |   |           |
  	  |   |   |           |
  	  |   |   |___     ___|
  	  |                   |
  	  |                   |
  	  |___________________|

A perfect maze!

`一个完美的迷宫！`

## Analysis 分析

Let’s analyze that a bit. It seemed to come together pretty magically, considering we weren’t looking at anything but the current row (and the next row, briefly). The key to it all are the sets.

`让我们来一点点分析下。它似乎很神奇的合在一起就成了。考虑到我们除了一行（和下一行，非常简单的过程）似乎没看到其他的东西。这一切的关键就在集合。`

The set that a cell belongs to tells the algorithm who its siblings were, are, and will be. It’s the crystal ball that lets the algorithm gaze into the future (and the past!) and avoid adding cycles and isolates to the maze.

`集合告诉了算法哪些单元格将被连通。就像一个水晶球，让算法可以看到未来（和过去）并且避免增加了单元格的遍历次数和孤立的迷宫。`

Cells that share a set, also share a path between them. (If you don’t believe me, look at the example I just gave, above. Every cell that shares a set identifier is connected; cells in different sets are not connected.)

`在一个集合内的单元格，也同样拥有连通的路径（如果你不信我，看看上面的例子，单元格在同一个集合内是有相同的数字标识的，是可以连通的，不在一个集合内则是不可以联通的）`

If the algorithm allowed us to create a passage between two cells that shared a set, it would be introducing a second path between those two cells. That’s essentially the definition of a loop or cycle in the graph, and since we don’t want cycles in our maze, we disallow that.

`如果算法允许我们创建一个通道，在两个集合里，那它将允许第二条路径存在那两个集合中，那实际上相当于定义了一个循环，因为我们不希望在我们迷宫中瞎转圈，所以我们不允许这样做。`

Conversely, cells that do not share a set, are not connected (they are disjoint). By the time we reach the end of the maze, every cell must be connected to every other cell, and the only way we can do that is if every set is eventually merged into a single set.

`相反，单元格不在一个集合内，它们不连通（不相交）。当我们处理迷宫的最后一行时，每个单元格必须被连接到其他的单元格。我们能做的就是把所有的集合合并为一个集合。`

We can’t do that if a set does not propogate itself to the next row. This is why the algorithm requires that at least one vertical passage be created for each set in the row. Otherwise, any set that didn’t create a vertical passage would become extinct after the current row. The result would be an isolate, an orphaned collection of cells that could never be reached from outside that set.

`我们必须让集合连通到下一行，这就是为什么算法要求每个集合至少创建一个向下连接的通道。否则，任一集合没有创建连到下一行的通道的话，其结果是，这个集合将被隔离，你可能无法从任意的路径到达这个集合。
`
Then, at the end, the algorithm joins all disjoint sets, allowing every cell in the the entire maze to be connected by a single, unique path to any other cell in the maze. And we’re done!

`那么，在最后，这个算法合并所有不在一起的集合。让所有的单元格在迷宫中被连接为一个集合，有唯一的路径在迷宫中连接任意的单元格。然后，我们完成了。`


[原文连接](http://weblog.jamisbuck.org/2010/12/29/maze-generation-eller-s-algorithm)
[版权限制](http://creativecommons.org/licenses/by-nc-sa/2.5/)
